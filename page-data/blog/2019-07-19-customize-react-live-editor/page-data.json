{"componentChunkName":"component---src-components-mdx-layout-js","path":"/blog/2019-07-19-customize-react-live-editor/","result":{"data":{"mdx":{"id":"747c9547-33a0-50ac-83c2-eebbe5448378","frontmatter":{"title":"Customize React-Live Editor","commentApiId":5},"timeToRead":1,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Customize React-Live Editor\",\n  \"draft\": true,\n  \"commentApiId\": 5\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"why-do-i-want-to-replace-the-react-live-editor\"\n  }, \"Why do i want to replace the react-live Editor?\"), mdx(\"p\", null, \"Because I like using react-live for these cool live code examples.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"live=true\",\n    \"live\": \"true\"\n  }), \"<BorderBox bg='blue.2' p={2} m={3}>\\n    <Text color='bodytext' m={2}>\\n        cool huh?\\n    </Text>\\n</BorderBox>\\n\")), mdx(\"p\", null, \"But i realized that i wasnt a fan of the editor they were using.\\nIm not going to point any fingers... or name any names, but i felt\\nthe editing experience could have been a little smoother. \"), mdx(\"p\", null, \"So i decided to try and see if I could use react-ace instead. \"), mdx(\"h2\", {\n    \"id\": \"investigation\"\n  }, \"Investigation\"), mdx(\"p\", null, \"First thing is I need to see how react-live has implemented its default editor to see\\nhow easy it may or may not be to customize the editor. \"), mdx(\"p\", null, \"Luckily the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LiveEditor\"), \" component is already a seperate piece of the api, so i can just define a\\ncustom \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LiveEditor\"), \" that uses react-ace. Also i noticed that react-live is using the React context\\napi to provide data from the editor to the previewer, so this may be eaiser than i had thought. \"), mdx(\"h2\", {\n    \"id\": \"start-coding\"\n  }, \"Start coding\"), mdx(\"p\", null, \"Now that we know what to do lets start by redefining the editor to use Ace. \"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"filename=editor.jsx\",\n    \"filename\": \"editor.jsx\"\n  }), \"export const CodeEditor = ({code, disabled, language, onChange, style, theme})=>{\\n\\n    const getCode = useMemo(()=> code, [code])\\n\\n    const [editorCode, setEditorCode] = useState(getCode)\\n\\n    const updateContent = useCallback(\\n        code =>{\\n            setEditorCode(code)\\n            onChange(code)\\n        }, [editorCode]\\n    )\\n    \\n    return (\\n        <AceEditor\\n            width={'100%'}\\n            value={editorCode}\\n            onChange={updateContent}\\n            style={style}\\n            name=\\\"blah\\\"\\n            mode={'jsx'}\\n            theme=\\\"monokai\\\"\\n            height=\\\"10vh\\\"\\n            showGutter={true}/>\\n    )\\n}\\n\")), mdx(\"p\", null, \"we just need to be sure that it has the same interface (ie: props) as the one\\nfrom react-live, that means:  \"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"code - the code to edit  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"disabled - self explanitory  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"language - what language should be used to define highlighting  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"onChange - callback for managing a controlled component  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"style - self explanitory  \"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"theme - we wont use this  \")), mdx(\"p\", null, \"So if you notice all we are really doing here is wrapping the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AceEditor\"), \" component to keep the state of the code,\\nmaking sure we rerender if it changes. \"), mdx(\"p\", null, \"Now lets redefine the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LiveEditor\"), \" component that mangages the live context and passes it to our editor.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"filename=live-editor.jsx\",\n    \"filename\": \"live-editor.jsx\"\n  }), \"import React, { useContext } from 'react'\\nimport { LiveContext } from 'react-live'\\nimport CodeEditor from './editor.jsx'\\n\\nexport const LiveEditor = props =>{\\n    const {\\n        code, language, theme, disabled, onChange\\n    } = useContext(LiveContext)\\n\\n    return (\\n        <CodeEditor \\n            {...props} \\n            theme={theme} \\n            code={code} \\n            language={language} \\n            disabled={disabled} \\n            onChange={onChange}/>\\n    )\\n}\\n\")), mdx(\"p\", null, \"So here we are just extracting the context provided by react-live and\\npassing it to our component. \"), mdx(\"p\", null, \"now we can just use it like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"filename=pre.jsx\",\n    \"filename\": \"pre.jsx\"\n  }), \"import {LiveError, LivePreview, LiveProvider} from 'react-live'\\n\\nimport { LiveEditor } from './editor'\\n\\nexport default ({code})=>(\\n<LiveProvider code={code}>\\n    <LivePreview/>\\n    <LiveEditor/>\\n    <LiveError/>\\n</LiveProvider>\\n)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"747c9547-33a0-50ac-83c2-eebbe5448378"}}}