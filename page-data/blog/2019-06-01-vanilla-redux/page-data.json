{"componentChunkName":"component---src-components-mdx-layout-js","path":"/blog/2019-06-01-vanilla-redux/","result":{"data":{"mdx":{"id":"e5c47d77-3bbe-5556-aad7-133788c667a4","frontmatter":{"title":"Vanilla Redux üìù","commentApiId":4},"timeToRead":3,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Vanilla Redux üìù\",\n  \"name\": \"Vanilla Redux\",\n  \"menu\": \"Blog\",\n  \"date\": \"2015-05-28T22:40:32.169Z\",\n  \"layout\": \"stacked\",\n  \"path\": \"/markdown/\",\n  \"category\": \"Typography\",\n  \"published\": true,\n  \"tags\": [\"Markdown\", \"Emoji\", \"graphql\"],\n  \"draft\": false,\n  \"commentApiId\": 4\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"img\", {\n    alt: \"vanilla\",\n    src: \"https://images.unsplash.com/photo-1561230101-2c841778f9ae?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&h=260&w=900&q=90&fit=crop\"\n  })), mdx(\"h1\", {\n    \"id\": \"vanilla-redux\"\n  }, \"Vanilla Redux\"), mdx(\"h2\", {\n    \"id\": \"why-just-redux\"\n  }, \"Why Just Redux?\"), mdx(\"p\", null, \"Many people have told me they find it difficult to learn react-redux.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"I think it is because even though they may know react,\\nif they have not yet run into redux it can be very confusing.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"So i found it useful to start out learning how to use redux by itself (\", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"without react\"), \").\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"After that when you need to connect your store to a react app\\nyou will have a much better idea of what is needed.\"), mdx(\"p\", null, \"So what does that mean? We can make a small command line task list app as an example.\"), mdx(\"p\", null, \"To start lets use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"yarn\"), \" to install our requirements, for this we will just use redux.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-bash\"\n  }), \"mkdir tasklist\\ncd tasklist\\nyarn init -y\\nyarn add redux uuid prompt\\n\")), mdx(\"p\", null, \"Once that finishes we can start by looking at what it means to use redux.\"), mdx(\"p\", null, \"It calls itself\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A predictable state container for javascript apps\")), mdx(\"h3\", {\n    \"id\": \"what-does-that-mean\"\n  }, \"What does that mean?\"), mdx(\"p\", null, \"Well if you are familiar with react then you are familiar with using state, more traditionally inside of class based Components, but more recently also in functional Components using hooks (which yes, sort of make redux useless, but you want to learn it, maybe because you have to support code using it).\"), mdx(\"p\", null, \"Basically it becomes the single source of truth in your app regarding state. If you need to check a value, you grab it from the redux store. If you want to update a value stored in the state, you pass an action to redux's dispatch function to kick off the update. It becomes very nice when you are working in a big project and you dont need to try to figure out how to update some value in the apps state, ie: which component handles it. You simply find or write the related action creator, and pass its return value to dispatch.\"), mdx(\"p\", null, \"So lets look at some concrete examples, but first lets go over what we need to do:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Figure out what data we need to store\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Choose what states we will need to support\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Define action type constants to represent our state changes\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Combine data and action types into helper functions aka: Action Creators\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Write reducer functions to perform our state updates\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Wire it into our task app\")), mdx(\"p\", null, \"So now lets think about what we want our app to do.\"), mdx(\"p\", null, \"A task list needs to be able to:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add a new task with text, and incomplete state\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"List existing tasks\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Set an incomplete task to complete\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Delete a task\")), mdx(\"p\", null, \"Now lets define what a task looks like\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-graphql\"\n  }), \"type Task {\\n  id: number\\n  text: String\\n  complete: Bool\\n}\\n\")), mdx(\"p\", null, \"At some point we should add a due date but for now all we really need is an object with a text property and a property to store its state, ill just call it complete and default it to false.\"), mdx(\"p\", null, \"First we need to import the stuff we want to use\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const uuid = require('uuid')\\nconst fs = require('fs')\\nconst prompt = require('prompt')\\nconst { createStore, combineReducers } = require('redux')\\n\")), mdx(\"p\", null, \"Now we will define our action types, in redux an action is an object, with a type and sometimes a payload of data.\", mdx(\"br\", {\n    parentName: \"p\"\n  }), \"\\n\", \"An action creator is a function that returns an action.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// action type constants\\nconst ADD_TASK = 'ADD_TASK'\\nconst MARK_COMPLETE = 'MARK_COMPLETE'\\n\")), mdx(\"p\", null, \"Now we can write some functions to return our action objects\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// action creator functions\\nconst addTaskAction = ({ text }) => ({\\n  type: ADD_TASK,\\n  payload: {\\n    text,\\n  },\\n})\\n\\nconst markCompleteAction = taskId => ({\\n  type: MARK_COMPLETE,\\n  payload: {\\n    taskId,\\n  },\\n})\\n\")), mdx(\"p\", null, \"Now we need to write a reducer, which is a function that will take our current state, and an action, and uses it to update the state\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const initialState = []\\n\\nconst taskListReducer = (\\n  state = initialState,\\n  { type, payload: { text, taskId } = {} }\\n) => {\\n  switch (type) {\\n    case ADD_TASK:\\n      return [\\n        ...state,\\n        {\\n          text,\\n          complete: false,\\n          id: uuid(),\\n        },\\n      ]\\n    case MARK_COMPLETE:\\n      return state.map(task => {\\n        if (task.id !== taskId) return task\\n        return { ...task, complete: true }\\n      })\\n    default:\\n      return state\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now for any of this to last after running, we need to have a way to save the data somehow, so we will just dump json to a file, and read from it to do that.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const loadInitialState = () => {\\n  return new Promise((resolve, reject) => {\\n    return fs.readFile('./tasks.json', (err, result) => {\\n      if (err) {\\n        reject(err)\\n      }\\n      let tasks\\n      try {\\n        tasks = JSON.parse(result.toString())\\n      } catch (e) {\\n        tasks = []\\n      }\\n      resolve({ tasks })\\n    })\\n  })\\n}\\n\\nconst saveState = ({ tasks }) => {\\n  const data = JSON.stringify(tasks)\\n  try {\\n    JSON.parse(data)\\n    fs.writeFile('./tasks.json', data, (err, res) => {})\\n  } catch (e) {\\n    console.log(err)\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now to tie redux up and have it ready we need to create our \\\"\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"store\"), \"\\\" using the aptly named redux function createStore, which takes 3 arguments:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Your root reducer (the combination of any reducers you have)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Any needed initial state\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"An \\\"enhancer\\\" which i wont use or go into further here.\")), mdx(\"p\", null, \"Since we want to load our tasks from a file, we need to tie that into creating our store:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const loadStore = () => {\\n  return loadInitialState().then(initialState => {\\n    return createStore(\\n      combineReducers({ tasks: taskListReducer }),\\n      initialState\\n    )\\n  })\\n}\\n\")), mdx(\"p\", null, \"Now that we have a store, that gives us the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" function we can use to execute our actions, so lets write some helper functions to do that for us.\"), mdx(\"p\", null, \"We need functions to:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Add a task\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Mark a task complete\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Display tasks  \")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const addTask = ({ dispatch }, text) => {\\n  dispatch(addTaskAction({ text }))\\n}\\n\\nconst markComplete = ({ dispatch }, taskId) => {\\n  dispatch(markCompleteAction(taskId))\\n}\\n\\nconst displayTasks = tasks => {\\n  tasks.forEach(({ text, complete }, index) => {\\n    console.log(`${index + 1} [${complete ? 'x' : ' '}] ${text}`)\\n  })\\n}\\n\")), mdx(\"p\", null, \"To get our user input, we will use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"prompt\"), \" libtrary. which takes an object config, namely \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"name\"), \" which is how the data is returned, and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"description\"), \" which is the question to ask the user.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const askWhatToDo = [\\n  {\\n    name: 'whatToDo',\\n    description:\\n      'what would you like to do?\\\\n[A] Add task\\\\n[L] List tasks\\\\n[C] Complete Task',\\n  },\\n]\\n\\nconst askWhatTaskToAdd = [\\n  {\\n    name: 'text',\\n    description: 'What should the text of the task be?',\\n  },\\n]\\n\\nconst askWhatTaskToComplete = [\\n  {\\n    name: 'taskIndex',\\n    description: 'What task Should we mark as complete?',\\n  },\\n]\\n\")), mdx(\"p\", null, \"Now lets tie the questions to our functions\"), mdx(\"p\", null, \"When they want to add a task we need to ask what the task is\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const doAddTask = store => {\\n  prompt.get(askWhatTaskToAdd, (err, { text }) => {\\n    console.log(`adding ${text}`)\\n    addTask(store, text)\\n  })\\n}\\n\")), mdx(\"p\", null, \"To complete a task we need to know which one to mark complete\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const doCompleteTask = store => {\\n  prompt.get(askWhatTaskToComplete, (err, { taskIndex }) => {\\n    const { tasks } = store.getState()\\n    const { id, text } = tasks[taskIndex]\\n    console.log(`completing ${text}`)\\n    markComplete(store, id)\\n  })\\n}\\n\")), mdx(\"p\", null, \"Listing the tasks is easy, no questions needed\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const doListTasks = store => {\\n  const { tasks } = store.getState()\\n  displayTasks(tasks)\\n}\\n\")), mdx(\"p\", null, \"Now lets tie it all together along with a question to find out what the user wants to do.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"loadStore().then(store => {\\n  store.subscribe(() => {\\n    const state = store.getState()\\n    saveState(state)\\n  })\\n  prompt.get(askWhatToDo, (err, { whatToDo }) => {\\n    const actions = {\\n      a: doAddTask,\\n      l: doListTasks,\\n      c: doCompleteTask,\\n    }\\n\\n    console.log(`you chose ${whatToDo}`)\\n\\n    actions[whatToDo.toLowerCase()](store)\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"id":"e5c47d77-3bbe-5556-aad7-133788c667a4"}}}